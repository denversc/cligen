#!/usr/bin/env python

# These "future" imports increase compatibility between Python 2 and Python 3
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals

import sys


class ArgumentParser(object):
    """
    Parses command-line arguments.
    Simply invoke the parse() method of this class to parse the arguments and return the result
    """

    def __init__(self, stdout=None, stderr=None):
        """
        Initializes a new instance of this class.

        *stdout* must be a file opened in write-text mode to which any "standard output" output
        generated by this object will be written; may be None (the default) to use sys.stdout.
        *stderr* must be a file opened in write-text mode to which any "standard output" output
        generated by this object will be written; may be None (the default) to use sys.stderr.
        """
        self.stdout = stdout if stdout is not None else sys.stdout
        self.stderr = stderr if stderr is not None else sys.stderr

    def parse(self, args=None, no_exit=None):
        """
        Parses the command-line arguments.

        Note that this method may never return.  If the application should terminate as a result of
        parsing the command-line arguments then sys.exit() will be invoked if the *no_exit* argument
        is None (the default) or evaluates to False.  If the *no_exit* argument evaluates to True
        then self.Error will be raised instead of invoking sys.exit(), delegating the responsibility
        of exiting the application to the caller.  There are several reasons why the command-line
        arguments parsing may result in the application exiting, including a parsing error in the
        argument parsing and printing the help screen.

        *args* must be an iterable of strings which are the arguments to parse;
        may be None (the default) to use sys.stdout[1:].
        *no_exit* will be evaluated as a boolean; if None (the default) or if it evaluates to False
        then sys.exit() will be invoked if the application should be terminated; if it evaluates to
        True then self.Error will be raised instead of exiting the application; see documentation
        above for more details.

        Returns an instance of self.ParsedArguments containing the parsed arguments.
        """
        if args is None:
            args = sys.argv[1:]
        arg_iterator = self._ArgumentIterator(args)

        parsed_args = self.ParsedArguments()
        try:
            while arg_iterator.has_next():
                self._parse_arg(arg_iterator, parsed_args)
        except self.ExitApplicationSuccessfully as e:
            if no_exit:
                raise
            sys.exit(e.exit_code)
        except self.InvalidCommandLineArguments as e:
            if no_exit:
                raise
            self.print_invalid_args(e)
            sys.exit(e.exit_code)
        except self.Error as e:
            if no_exit:
                raise
            self.print_error(e)
            sys.exit(e.exit_code)

        return parsed_args

    def _parse_arg(self, arg_iterator, parsed_args):
        arg = arg_iterator.peek()
        if arg is None:
            pass
        elif self._parse_positional_arg(arg_iterator, parsed_args):
            pass
        {% for arg in argspec.arguments %}
        elif self._parse_arg_{{ arg|varname }}(arg_iterator, parsed_args):
            pass
        {% endfor %}
        else:
            raise self.UnknownArgument("unknown argument: {}".format(arg))

    {% for arg in argspec.arguments %}
    def _parse_arg_{{ arg|varname }}(self, arg_iterator, parsed_args):
        arg = arg_iterator.peek()
        if arg is None:
            return False
        {% for key in arg.keys %}
        elif arg == "{{key}}":
            arg_iterator.advance()
        {% endfor %}
        else:
            return False

        {% if arg.type == arg.TYPE_BUILTIN_HELP %}
        self.print_help()
        raise self.ExitApplicationSuccessfully()
        {% else %}
        value = arg_iterator.next()
        if value is None:
            raise self.ArgumentValueMissing("{} must be followed by a value".format(arg))
        parsed_args.{{ arg|varname }} = value
        return True
        {% endif %}

    {% endfor %}

    def _parse_positional_arg(self, arg_iterator, parsed_args):
        arg = arg_iterator.peek()
        if arg is None or arg.startswith("-"):
            return False
        else:
            arg_iterator.advance()

        raise self.UnexpectedArgument("unexpected argument: {}".format(arg))

    @staticmethod
    def print_lines(lines, f):
        for line in lines:
            print(line, file=f)

    def print_invalid_args(self, error, f=None):
        if f is None:
            f = self.stderr
        lines = self.get_invalid_args_lines(error)
        self.print_lines(lines, f)

    @staticmethod
    def get_invalid_args_lines(error):
        yield "ERROR: invalid command-line arguments: {}".format(error)
        {% if argspec.help_argument %}
        yield "Run with {{ argspec.help_argument|most_descriptive_key}} for help"
        {% endif %}

    def print_error(self, error, f=None):
        if f is None:
            f = self.stderr
        lines = self.get_error_lines(error)
        self.print_lines(lines, f)

    @staticmethod
    def get_error_lines(error):
        message = "{}".format(error)
        none_message = "{}".format(None)
        if message != none_message:
            yield "ERROR: {}".format(message)

    def print_help(self, f=None):
        if f is None:
            f = self.stdout
        lines = self.get_help_lines()
        self.print_lines(lines, f)

    @classmethod
    def get_help_lines(cls):
        yield "The following command-line arguments are recognized:"
        {% for arg in argspec.arguments %}
        yield ""
        {% for key in arg.keys %}
        yield "{{key}}"
        {% endfor %}
        {% if arg.help_text %}
        yield "    {{arg.help_text}}"
        {% endif %}
        {% endfor %}

    class ParsedArguments(object):
        """
        Stores the parsed command-line arguments.
        An instance of this class is returned from ArgumentParser.parse().
        """

        def __init__(self):
            """
            Initializes a new instance of this class, setting each attribute to its default value.
            """
            {% for arg in argspec.arguments if arg.supports_values() %}
            self.{{ arg|varname }} = None
            {% endfor %}

        def print(self, f=None):
            """
            Prints the parsed command-line arguments stored in this object, one per line.
            This method is primarily intended for debugging purposes

            *f* must be a file object opened in write-text mode to which the output will be written;
            may be None (the default) to use sys.stdout.
            """
            if f is None:
                f = sys.stdout

            {% for arg in argspec.arguments if arg.supports_values() %}
            print("{{ arg|most_descriptive_key }} {}".format("[not set]" if self.{{ arg|varname }} is None else self.{{ arg|varname }}), file=f)
            {% endfor %}

    class _ArgumentIterator(object):

        def __init__(self, args):
            self.args = args
            self.index = 0

        def peek(self):
            if self.index >= len(self.args):
                return None
            else:
                return self.args[self.index]

        def next(self):
            arg = self.peek()
            self.advance()
            return arg

        def has_next(self):
            return (self.peek() is not None)

        def advance(self):
            self.index += 1

    class Error(Exception):
        """
        The exception raised if the application should terminate as a result of command-line
        arguments parsing.
        The *exit_code* attribute will be an int whose value is a recommended exit code to specify
        to sys.exit() to terminate the application.
        """

        # the exit code conventionally used to indicate that the application finished successfully
        EXIT_CODE_SUCCESS = 0

        # the exit code conventionally used to indicate that the application finished
        # unsuccessfully, except for command-line arguments parsing errors
        EXIT_CODE_FAIL = 1

        # the exit code conventionally used to indicate that the application finished
        # unsuccessfully, due to command-line arguments parsing errors
        EXIT_CODE_INVALID_ARGS = 2

        def __init__(self, message, exit_code):
            """
            Initializes a new instance of this class.
            *message* must be a string whose value describes the error.
            *exit_code* must be an int whose value is the recommended exit code to specify to
            sys.exit() in response to this error.
            """
            super(ArgumentParser.Error, self).__init__(message)
            self.exit_code = exit_code

    class ExitApplicationSuccessfully(Error):
        """
        Exception raised to indicate that the arguments parsing was indeed successful, but the
        application should immediately terminate successfully nonetheless.
        For example, this exception is raised if the builtin --help argument is specified.
        """

        def __init__(self, message=None, exit_code=None):
            if exit_code is None:
                exit_code = self.EXIT_CODE_SUCCESS
            super(ArgumentParser.ExitApplicationSuccessfully, self).__init__(
                message=message, exit_code=exit_code)

    class InvalidCommandLineArguments(Error):
        """
        Exception raised if the command-line arguments parsing fails due to invalid arguments,
        missing arguments, etc.
        """

        def __init__(self, message=None, exit_code=None):
            if exit_code is None:
                exit_code = self.EXIT_CODE_INVALID_ARGS
            super(ArgumentParser.InvalidCommandLineArguments, self).__init__(
                message=message, exit_code=exit_code)

    class ArgumentValueMissing(InvalidCommandLineArguments):
        """
        Exception raised if a command-line argument requires a value to follow it but that value
        is missing.

        For example, suppose the parser recognizes the --name argument which is required to be
        followed by a name as the next argument; if there are no arguments specified after --name
        on the command line then this exception will be raised.
        """

    class UnknownArgument(InvalidCommandLineArguments):
        """
        Exception raised if a command-line argument is not a recognized option.

        For example, suppose the parser recognizes the options --name and --title but the
        argument --subject was specified; the presence of the --subject option would cause
        this exception to be raised.
        """

    class UnexpectedArgument(InvalidCommandLineArguments):
        """
        Exception raised if a command-line argument is specified when none is expected.

        For example, suppose the parser recognizes the options --name and the arguments
        "--name Peter hello" were specified; the "hello" argument would cause this exception to
        be raised since it is an orphaned positional argument and the parser does not recognize
        positional arguments.
        """


# Allows this file to be run as an application to test parsing command-line arguments
if __name__ == "__main__":
    parser = ArgumentParser()
    parsed_args = parser.parse()
    parsed_args.print()
